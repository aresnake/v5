# ares/tools/intent_resolver.py

import bpy
import traceback
from ares.core.logger import get_logger
from ares.tools.operator_classifier import classify_operator

log = get_logger("IntentResolver")


def resolve_and_execute(intent: dict) -> bool:
    name = intent.get("name", "intent_sans_nom")
    operator = intent.get("operator")
    params = intent.get("params", {}) or {}

    operator_type = classify_operator(operator)
    log.info(f"🔍 Résolution de l'opérateur : {operator} (type: {operator_type})")

    try:
        if operator_type == "ops":
            op_path = operator.split(".")
            if len(op_path) != 2:
                log.error(f"❌ Format invalide pour opérateur : {operator}")
                return False

            category, command = op_path
            op_module = getattr(bpy.ops, category, None)
            if not op_module:
                log.error(f"❌ Catégorie inconnue : bpy.ops.{category}")
                return False

            op_func = getattr(op_module, command, None)
            if not op_func or not callable(op_func):
                log.error(f"❌ Commande inconnue : bpy.ops.{category}.{command}")
                return False

            if hasattr(op_func, "poll") and not op_func.poll():
                log.warning(f"⚠️ Contexte invalide pour {operator} (poll()=False)")
                return False

            result = op_func(**params)
            log.info(f"✅ Opérateur {operator} exécuté avec succès → {result}")
            return True

        elif operator_type == "context":
            log.warning(f"⚠️ Exécution directe via bpy.context.* non encore implémentée pour : {operator}")
            return False

        else:
            log.warning(f"❌ Type d'opérateur non supporté : {operator_type}")
            return False

    except Exception as e:
        log.error(f"❌ Erreur pendant l'exécution de {operator} : {e}")
        traceback.print_exc()
        return False
